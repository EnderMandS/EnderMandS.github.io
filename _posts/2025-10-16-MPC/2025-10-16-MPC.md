---
layout: post
title: "Model predictive control"
date: 2025-10-16 09:24:00 +0800
categories: [Algorithm, Control]
---

# Model predictive control

模型预测控制（Model Predictive Control，简称 MPC）是一种基于模型的先进控制策略，广泛应用于工业过程控制、自动驾驶、机器人、能源系统等领域。它的核心思想是：利用系统模型预测未来行为，并通过优化算法决定当前的控制动作。

下面我们分步骤来理解 MPC 的原理：

## 核心组成部分

1. **模型（Model）**
   - 描述系统的动态行为，通常是线性或非线性差分方程。
   - 可以是物理建模（如牛顿定律）或数据驱动建模（如神经网络）。

2. **预测（Prediction）**
   - 使用模型预测未来一段时间内系统的状态和输出。
   - 预测时间长度称为“预测时域”（Prediction Horizon）。

3. **优化（Optimization）**
   - 在每个控制时刻，求解一个优化问题，目标是使未来输出尽可能接近期望值，同时满足约束。
   - 优化变量是未来的控制输入序列。

4. **滚动时域（Receding Horizon）**
   - 每次只执行优化结果中的第一个控制动作，然后进入下一个时刻重新预测和优化。
   - 这种方式使控制器具有反馈能力，能应对模型误差和外部扰动。

## 数学原理

### 基本模型与预测  
系统以离散时间线性状态空间模型描述：  
$$
x_{k+1} = A\,x_k + B\,u_k,  
\quad  
y_k = C\,x_k  
$$  
其中 $x_k$ 为状态向量，$u_k$ 为控制输入向量，$y_k$ 为输出向量，$A,B,C$ 为已知常数矩阵。  

在时刻 $k$，设定预测时域长度为 $N$，需要预测未来 $N$ 步的状态序列  
$\{x_{k+1|k}, \dots, x_{k+N|k}\}$ 与控制序列  
$\{u_{k|k}, \dots, u_{k+N-1|k}\}$。  

根据模型，第 $i$ 步预测状态可写为：  
$$
x_{k+i|k}
= A^i\,x_k
  + \sum_{j=0}^{i-1} A^{\,i-1-j} B\,u_{k+j|k}  
$$  

为了统一表示，引入堆叠向量  
$$
X = \begin{bmatrix} x_{k+1|k} \\ \vdots \\ x_{k+N|k} \end{bmatrix},  
\quad  
U = \begin{bmatrix} u_{k|k} \\ \vdots \\ u_{k+N-1|k} \end{bmatrix}  
$$  
并定义  
$$
X = \mathcal{A}\,x_k + \mathcal{B}\,U
$$  
其中  
$\mathcal{A}\in\mathbb{R}^{nN\times n}$ 与  
$\mathcal{B}\in\mathbb{R}^{nN\times mN}$ 为预测矩阵，分别由 $A$ 与 $B$ 的幂次和排列构成。  

其中 $\mathcal{A}\in\mathbb{R}^{nN\times n}$、$\mathcal{B}\in\mathbb{R}^{nN\times mN}$ 分别由 $A$ 和 $B$ 的幂次与排列构成

## 设计目标函数  

在路径规划中，通常将“预测状态”与“期望轨迹” $R$（堆叠形式）之间的偏差，以及控制输入的使用量同时纳入代价：  
$$
J(U)
=\bigl\|X-R\bigr\|_{Q_N}^2+\bigl\|U\bigr\|_{R_N}^2
=(X-R)^\mathsf{T}Q_N(X-R)+U^\mathsf{T}R_NU
$$  
其中  
- $Q_N=\mathrm{diag}(Q,\dots,Q,S)$ 为预测时域状态权重；  
- $R_N=\mathrm{diag}(R,\dots,R)$ 为输入权重；  
- $R$ 对应于期望位置、速度等目标轨迹。

将 $X$ 代入得到关于 $U$ 的二次型  

把堆叠预测方程带入上式：  
$$
J(U)
=\bigl(\mathcal{A}x_k+\mathcal{B}U-R\bigr)^\mathsf{T}
\,Q_N\,
\bigl(\mathcal{A}x_k+\mathcal{B}U-R\bigr)
+U^\mathsf{T}R_NU.
$$  
展开并整理，可得到标准二次规划形式：  
$$
J(U)
=\tfrac12\,U^\mathsf{T}H\,U+f^\mathsf{T}U+\text{常数},
$$  
其中  
$$
H=2\bigl(\mathcal{B}^\mathsf{T}Q_N\mathcal{B}+R_N\bigr),
\quad
f=2\,\mathcal{B}^\mathsf{T}Q_N\bigl(\mathcal{A}x_k-R\bigr).
$$  
这样就把原始的“状态预测”模型，转换为了一个关于控制序列 $U$ 的二次型优化问题。

## 目标函数

MPC 通过二次型目标函数权衡跟踪误差与控制消耗，其一般形式为：  
$$
J(U) 
= \tfrac{1}{2}\,x_{k+N|k}^\mathsf{T} S \,x_{k+N|k}
+ \tfrac{1}{2}\sum_{i=0}^{N-1} 
  \Bigl(x_{k+i|k}^\mathsf{T} Q \,x_{k+i|k} 
       + u_{k+i|k}^\mathsf{T} R \,u_{k+i|k}\Bigr)
$$  
其中  
- $Q\succeq 0$ 为阶段状态权重矩阵，  
- $R\succ 0$ 为阶段输入权重矩阵，  
- $S\succeq 0$ 为终端状态权重矩阵，  
- 常取 $Q = C^\mathsf{T}C$ 或根据性能需求设计。  

将堆叠形式代入，可写成标准二次规划（QP）形式：  
$$
J(U) = \tfrac{1}{2} U^\mathsf{T} H \,U +  
       x_k^\mathsf{T} F^\mathsf{T}\,U + \text{常数项}
$$  
其中  
$$
H = \mathcal{B}^\mathsf{T} Q_{\!N}\,\mathcal{B} + R_N,  
\quad
F = \mathcal{A}^\mathsf{T} Q_{\!N}\,\mathcal{B}
$$  
且  
$$
Q_{\!N} = \mathrm{diag}(Q,\dots,Q,S),  
\quad  
R_N = \mathrm{diag}(R,\dots,R)
$$  

### Q、R、S 矩阵的物理含义

#### Q 矩阵：状态偏差权重

Q 决定了系统对状态（或输出）偏差的“在意程度”。  

从物理角度看，它反映了对关键量（如温度、压力、位置、速度等）偏离目标值的惩罚力度。  

当 Q 中某个分量较大时，控制器会优先减小该分量的跟踪误差，哪怕付出更多的控制能量或使其他状态偏差稍增。  

#### R 矩阵：控制能耗权重

R 决定了对控制输入（如阀门开度、马达电流、加速度等）的“付出代价”。  

在物理层面，它对应于执行机构的能耗、系统的功率消耗、机械磨损或速率限制。  

当 R 较大时，控制器会更保守，尽量减少输入幅值或频繁调整，以节约能量、降低磨损并提高安全裕度。  

#### S 矩阵：终端状态权重

S 是对预测时域末端状态的附加权重，通常用于补偿有限预测窗口带来的截断效应。  

在物理意义上，它相当于对无限长时域性能的一个近似惩罚，使系统在末端状态也能向目标靠拢。  

适当设计 S 可以提升闭环稳定性与鲁棒性，避免预测窗口之外状态发散。  

- Q 与 R 共同平衡“性能”与“代价”：  
  - 高 Q、低 R → 强调快速跟踪，能耗高；  
  - 低 Q、高 R → 强调节能平稳，跟踪速度慢。  
- S 的选取常基于线性二次调节（LQR）的终端 Riccati 方程解，或取为 Q 的放大版。 

## 约束条件  
MPC 可显式处理输入与状态约束：  
- 状态约束  
  $\,x_{\min}\le x_{k+i|k}\le x_{\max},\;\forall\,i=1,\dots,N$  
- 输入约束  
  $\,u_{\min}\le u_{k+i|k}\le u_{\max},\;\forall\,i=0,\dots,N-1$  

上述可统一写为线性不等式：  
$$
G\,U \le h + E\,x_k
$$  
其中 $G,E,h$ 根据 $\mathcal{A},\mathcal{B}$ 及上下限构建。

## 优化问题与求解  
在时刻 $k$ 求解以下二次规划：  
$$
\begin{aligned}
\min_{U}\;& \tfrac{1}{2} U^\mathsf{T} H\,U + x_k^\mathsf{T}F^\mathsf{T}U \
\text{s.t.}\;& G\,U \le h + E\,x_k
\end{aligned}
$$  
解得最优控制序列 $U^*$，实际仅实施第一步 $u_{k|k} = U^*_0$。  

此 QP 可用内点法或活跃集法等高效算法实时求解。  

## 滚动时域执行  
1. 测量或估计当前状态 $x_k$。  
2. 求解上述 QP，得到 $U^*$。  
3. 应用 $u_{k} = U^*_0$；系统前进一步。  
4. $k \leftarrow k+1$，更新状态并重复步骤 1–3。  

这种滚动时域（receding horizon）策略使 MPC 对扰动和模型不确定性具备反馈修正能力。  

