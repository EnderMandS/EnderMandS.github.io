---
layout: post
title: "4DGS"
date: 2025-08-21 10:29:00 +0800
categories: [Paper, 3DGS]
---

# 4DGS

Paper: [https://arxiv.org/abs/2310.08528](https://arxiv.org/abs/2310.08528)

Code: [https://github.com/hustvl/4DGaussians](https://github.com/hustvl/4DGaussians)

核心：

1. 将动态场景表示为一组固定的 3D 高斯 + 高效的高斯形变场网络，而不是为每一帧单独存储高斯。形变场负责在任意时间戳预测高斯的位置、旋转、缩放变化，实现运动和形变的统一建模。

2. 空间-时间结构编码器（Spatial-Temporal Structure Encoder）：基于多分辨率 HexPlane（6 个二维平面：空间 3 个 + 时间 3 个）编码高斯的时空特征。相比直接 4D 体素，显著降低内存消耗。

3. 多头高斯形变解码器（Multi-head Gaussian Deformation Decoder）：分别预测位置、旋转、缩放的变化量（ΔX, Δr, Δs）。支持细粒度的形变控制，提升动态细节拟合能力。

## 流程

### 高斯初始化

1. 收集相机参数和初始稀疏点云：利用 Structure-from-Motion (SfM) 复现初始帧的稀疏三维点集，每个点视作高斯分布（Gaussian），以其坐标作为均值$X$，固定初始协方差矩阵$\Sigma$

2. 预热训练（约 3000 iter）, 仅使用经典的3DGS渲染流程, 快速收敛到合理的几何表示, 稳定几何结构

### 空时结构编码 Spatial-Temporal Structure Encoder

4D K-Planes 分解 ->  MLP 融合计算时空嵌入向量

#### 4D K-Planes 分解

4D K‑Planes把一个四维体素场（空间与时间，坐标为 $ \left ( x, y, z, t \right ) $ ）显式分解为六组二维“切片”平面 $ \left ( x, y \right ), \left ( x, z \right ), \left ( y, z \right ), \left ( x, t \right ), \left ( y, t \right ), \left ( z, t \right ) $ 

构建 6 个全局共享的多分辨率特征平面，这些平面共同组成了分解后的 4D 神经体素（HexPlane 模块），每个分辨率下都有一组这样的 2D 平面。对于任意一个高斯点，先取其中心 $ \left ( x, y, z, t \right ) $ 在每对维度上的投影，归一化到 $ \left [ -1, 1 \right ] $ 再 reshape 成形状 $ \left ( N,1,1,2 \right )  $ 的网格

分解的优点:
- 降维与省内存: 直接用 4D 体素的内存随 $ N_{x, y, z}^{3} \times N_t $ 指数增长; K‑Planes 以六个二维网格替代一个四维网格，使参数规模按平面大小线性增长，在同等容量下更高效
- 结构先验更友好: 三个“空间平面”聚焦静态几何与纹理结构，三个“时空平面”专注沿各坐标轴的运动与变形模式，把“形状”和“运动”解耦成易学的子问题，学习更稳定
- 多分辨率更容易: 每个平面都可以做多层次（多分辨率）表示与上采样，既抓大结构也补细节，再由一个轻量 MLP 融合，兼顾质量与速度

#### 上采样插值

对于任意查询点 $ \left ( x, y, z, t \right ) $ 分别在这六个平面上做双线性插值取特征。在每个平面 $ R_l\left ( i,j \right )  $ 上, 根据对应的二维坐标做双线性插值，得到平面特征:

$$ f_h = \bigcup_{l}\prod \mathrm{interp} \left [ R_l\left ( i,j \right ) \right ] $$

$$ \left ( i,j \right ) \in \left \{ \left ( x, y \right ), \left ( x, z \right ), \left ( y, z \right ), \left ( x, t \right ), \left ( y, t \right ), \left ( z, t \right ) \right \}  $$

在每个2D平面上, 存的是一个 $H\times W \times C$ 的特征表（C 是通道数）

每个平面会有多组不同分辨率的特征表（例如 64×64、128×128、256×256）. 对同一个查询点，会在每个分辨率的平面上分别做双线性插值，得到多组 C 维向量

给定查询点的二维坐标（归一化到平面网格范围），会在该平面上找到它落入的四个网格点，按双线性权重插值出一个 C 维向量

同一平面可有多层尺度（如基础分辨率与若干上采样层），插值后级联或求和以增强细节

#### 平面特征融合

把六路（或多尺度）特征拼接，输入小型MLP $\phi_d$ 将这 6 份特征融合，输出每个高斯的空时嵌入 $f_d = \phi_d \left( f_h \right)$

融合方式: 
- 级联`concat`: 直接把不同分辨率的向量拼接成一个更长的向量（常见做法，信息保留完整）
- 求和`sum`: 逐通道相加，得到一个 C 维向量（更省内存，但可能损失细节）

K‑Planes 已提供强先验，融合网络保持小型有利于实时性与稳定训练

### 多头高斯变形解码 Multi-head Gaussian Deformation Decoder

1. 变形参数预测
    - 位置变形头 $ \phi_x $: 预测中心位移 $ \Delta X = \phi_x \left ( f_d \right ) $
    - 旋转变形头 $ \phi_r $: 预测四元数微调 $ \Delta r = \phi_r \left ( f_d \right ) $，应用于协方差旋转分解
    - 缩放变形头 $ \phi_s $: 预测协方差缩放 $ \Delta s = \phi_s \left ( f_d \right ) $, 对应协方差矩阵的尺度变化

2. 构建时刻 $t$ 的 3D 高斯集合: 对每个高斯执行:

$$ X^{'} = X + \Delta X, \quad r^{'} = r + \Delta r, \quad s^{'} = s + \Delta s $$

由此得到新的高斯集 $ G^{'} = \left \{ X^{'}, \Sigma^{'}, C, \alpha  \right \}  $ ，然后进行标准3DGS渲染

### 优化

损失函数: $ L = \left | \hat{I} - I \right |_1 + L_{tv} $

其中 $ L_{tv} $ 为 grid-based total-variational loss 平滑正则化, 对多分辨率平面参数施加总变分损失, 抑制过度振荡

训练: Warm-up：仅优化 3,000 次静态高斯；联合优化：同时微调高斯 $G$ 与变形场网络 
$ F $，共约 20,000 次迭代收敛

## 问题

保证 $ \left( x,y,z,y \right) $ 在各平面坐标内均匀分布；越界可裁剪或镜像，避免插值异常

大运动与遮挡: 单目、剧烈形变或大位移时，时空平面的表达可能容量不足或落入局部最优；可引入更多监督（深度/光流）或提高时空平面分辨率缓解

多分辨率与通道数: 每个平面采用多尺度表征（例如基础分辨率配合 2×、4×上采样），通道维度适中，过大易过拟合、过小欠拟合

K‑Planes 更省内存、速度更友好；极端复杂运动或强拓扑变化时，可能需要更大容量（更多通道/分辨率/正则）来弥补表达力
